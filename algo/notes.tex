\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\DeclareUnicodeCharacter{2212}{-}

\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{shapes.arrows,chains,trees}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{hypothesis}{Hypothesis}[section]
\newtheorem{example}{Example}[section]

\newcommand{\G}{\mathcal{G}}

\setlength{\parindent}{0pt}

\begin{document}

\tableofcontents
\pagebreak

\section{Problems}
Firstly we shall look at two problems which belong to the complexity class NP.

\textbf{Traveling Sales Person}\\
Consider a finite set $N$ of cities; $\{1, 2 \dots n\}$. The distance, or cost,
of traveling between cities $i$ and $j$ is given by $D(i,j)$ where $D$
is a symmetric matrix.

$$\forall\ i, j\quad D(i,J) \in \mathbb{N}\quad D(i,j) = D(j,i)$$

The problem is to find a path, or permutation, of
cities where each city appears exactly once in the path and the total
cost is minimised.

The brute force solution is to consider all paths, doing this would require
considering $!n$ paths.

\textbf{Boolean Formula Satisfiability}\\
A boolean formula consists of the logical binary operators $(\land, \lor, \neg)$
and a finite set of variables $X$ where each variable can be either true or false.
The problem consists of deciding if there exists a set of values for the variables $X$
which results in the boolean formula being true.

$$(x_1 \land x_2) \land \neg x_3$$

$$(x_1 \land x_2) \land \neg x_1$$

A brute force solution would be to consider all $2^{|X|}$ possible assignments.

The link between these two problems is the na\"ive brute force solution is not
tractable for large values of $n$.

\begin{itemize}
    \item \textbf{Input}: Real numbers $x_1,\dots x_n$
    \item \textbf{Output}: Yes iff there exists a subset of $x_i$ which sum to 1.
\end{itemize}

\include{problems}

\pagebreak
\include{turing}

\include{big_o}

\pagebreak
\include{equivalence}

\pagebreak
\include{class_p_np}

\pagebreak
\include{cooks}

%\pagebreak
%\include{knapsack}

\pagebreak
\include{approx}

\pagebreak
\include{lower_bounds}

\pagebreak
\include{quantum}

\end{document}
